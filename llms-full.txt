--- /var/home/j4jk3wka/Code/computer-master-bot/packages/bot-machine/AI_AGENT_FRAMEWORK_REQUIREMENTS.md ---


# R&D Report: Architecting Frameworks for the AI Developer

**Department:** R&D, @kaizinx

**Authors:** eugenekaizin, Gemini Agent

**Status:** Draft

## Executive Summary

This report introduces a critical new stakeholder in software development: the **AI Coding Agent**. As development workflows become increasingly AI-assisted, the frameworks we build must be optimized for programmatic understanding and manipulation. Our research concludes that designing for an AI stakeholder does not merely accommodate it, but results in architectural patterns that are demonstrably superior for human developers as well, leading to more robust, maintainable, and predictable systems.

We identify two paramount requirements for an "AI-native" framework:

1.  **Schema-First Data Contracts:** All boundaries between system components (e.g., UI and business logic) must be defined by machine-readable schemas (e.g., using Zod), eliminating the ambiguity of `any` types.
2.  **Type-Safe State Transitions:** State machines and routers must eliminate "magic strings" in favor of type-safe, discoverable APIs for defining states and transitions.

This report details the core needs of an AI agent and translates them into these actionable architectural requirements, using the in-development `bot-machine` framework as a case study.

---

## 1. Introduction: The New Stakeholder

Traditionally, software frameworks are designed with a single audience in mind: the human developer. We optimize for readability, ergonomics, and cognitive load. However, the rise of powerful Large Language Models (LLMs) integrated into our IDEs introduces a new, non-human developer persona: the **AI Coding Agent**.

This agent is not merely a tool for autocompletion; it is an active participant in the development process, capable of writing, refactoring, and debugging large blocks of code. To collaborate with this new stakeholder effectively, we must ask: **What does a framework look like when its primary user might be another program?**

This report explores this question. We posit that by treating the AI agent as a first-class citizen, we can derive a set of design principles that lead to exceptionally high-quality frameworks.

## 2. Core Needs of the AI Agent Developer

An AI agent "thinks" in terms of tokens, probabilities, and abstract syntax trees. It lacks human intuition and the ability to infer context from disparate sources. Its ideal environment is one of high signal and low noise. We have identified four core needs:

#### 2.1. Predictability & Explicitness

An AI agent thrives on clear, unambiguous instructions. Implicit behaviors, "magic" functions that work based on naming conventions, or actions with hidden side effects are sources of immense confusion and lead to probabilistic, often incorrect, code generation. The agent must be able to look at a piece of code and predict its behavior with near-certainty.

*   **Implication:** Favor explicit configuration over convention. State transitions, dependencies, and data flow must be clearly spelled out in the code.

#### 2.2. Introspection & Discoverability

How does an agent learn an API? It cannot read blog posts or watch tutorials. Its primary source of truth is the code itself, specifically the **type definitions**. TypeScript is not just a tool for human-readable code; for an AI, it is the primary means of discovering a framework's capabilities. A well-defined type is equivalent to a chapter of documentation.

*   **Implication:** Strongly typed interfaces and machine-readable schemas are not optional; they are the documentation.

#### 2.3. Composability & Low Boilerplate

Agents excel at reasoning about and combining small, self-contained, stateless units of logic. Large, monolithic classes or functions with extensive boilerplate are difficult to modify correctly, as the agent must understand the entire context before making a change. A framework built on the principle of composition allows the agent to operate on small, focused parts of the system, leading to more reliable results.

*   **Implication:** Design the framework around small, pure, composable functions and components.

#### 2.4. Clear Separation of Concerns

When a human is asked to "add a button to the user profile screen," they use their knowledge of the app to find the right file. An agent needs a more explicit map. A clear and consistent architectural pattern (e.g., separating UI, state management, and business logic) is essential. This allows the agent to be given a targeted instruction and reliably locate the correct part of the codebase to modify.

*   **Implication:** Enforce a clean, layered architecture where the responsibilities of each module are obvious.

## 3. From Needs to Requirements: A Case Study with `bot-machine`

Analyzing our `bot-machine` framework through the lens of these needs reveals critical areas for improvement. What is merely an inconvenience for a human is a significant roadblock for an AI.

### Requirement 1: Type-Safe State Transitions

*   **Problem:** Our `FlowController` uses strings to define state transitions: `nextState: 'counter'`. This is a classic "magic string". It's prone to typos, and an AI has no way of knowing the available states other than parsing the entire configuration object.

*   **AI-Native Solution:** The framework itself should provide a type-safe way to reference states.

    ```typescript
    // Hypothetical improved API
    const mainFlow = createFlow({
      // The keys of this object define the states
      counter: { ... },
      rename: { ... },
    });

    // In the 'rename' state config:
    {
      // ...
      // The AI (and human) gets autocomplete and compile-time safety!
      nextState: mainFlow.states.counter
    }
    ```

### Requirement 2: Schema-First Data Contracts

*   **Problem:** The boundary between our framework and the business logic is untyped. A `command` function receives a `payload: any` and returns a `Promise<any>`. An AI cannot know what data to pass to the command or what to expect in return.

*   **AI-Native Solution:** Integrate a schema library like **Zod** to create explicit, machine-readable contracts for all business logic functions.

    ```typescript
    // Before: The AI has to guess the shape of `payload` and the return value.
    const renameCounterCommand: CommandFunction = async (payload, ctx) => {
      const newName = payload.newName; // Is it newName? or name? Is it a string?
      // ...
    }

    // After: The contract is explicit and validated at runtime.
    import { z } from 'zod';

    const renameCounterCmd = createCommand({
      input: z.object({ newName: z.string().min(1) }),
      output: z.object({ name: z.string(), count: z.number() }),
      execute: async ({ input, ctx }) => {
        // The AI knows `input` is `{ newName: string }`.
        // It also knows the function MUST return an object with a name and count.
        // ...
        return { name: input.newName, count: 1 };
      }
    });
    ```

## 4. Conclusion: The Human-AI Symbiosis

Adopting these AI-centric design principles is not an academic exercise. The outcome is a framework that is profoundly better for human developers.

*   **Schema-first design** eliminates an entire class of runtime errors and provides rich, documentation-as-code.
*   **Type-safe transitions** make refactoring trivial and leverage the full power of IDE autocompletion.
*   **A composable API** leads to cleaner, more modular, and more testable code.

By designing for the most demanding, logic-driven, and context-unaware developer on our team (the AI agent), we create an environment of extreme clarity. This clarity benefits everyone, making the development process faster, safer, and more enjoyable.

## 5. Recommendations

For the `bot-machine` project, we recommend prioritizing the implementation of these findings to validate their impact. The next immediate step is to **integrate Zod for schema-defined business logic commands**, as this provides the most significant and immediate improvement to the framework's robustness and DX for all stakeholders, both human and artificial.


--- /var/home/j4jk3wka/Code/computer-master-bot/packages/bot-machine/AI_DRIVEN_WORKFLOW.md ---


# AI-Driven Workflow: Development Methodology for `bot-machine`

## Core Principle

Development follows a **top-down, schema-first** approach. We begin by describing **WHAT** the system does (its data structures, states, and transitions) before defining **HOW** it does it (the implementation logic). This workflow allows an AI agent (or a human developer following the discipline) to proceed with maximum confidence at each step, ensuring the system remains consistent and type-safe throughout the entire process.

The development of a new feature (e.g., "pizza ordering") proceeds through the following steps.

---

### Step 1: Decompose & Define Contracts (Schema-First)

This is the most critical phase, executed within the `/src/core/` directory. We do not write implementation logic here. We describe the **data**.

1.  **Identify Entities:** What data does the feature operate on?
    *   *Example: "For a pizza order, we need its `size`, `type`, and delivery `address`."*

2.  **Define Commands & Queries:** What actions and data requests are necessary?
    *   *Example: "We need a `createOrderCommand` and a `getOrderQuery`."*

3.  **Write the Schemas (Zod):** For each command and query, we define the input and output data structures using Zod. This forms our **machine-readable contract**.

    *AI Agent Action: Create `src/core/pizza.ts`*
    ```typescript
    import { z } from 'zod';
    import { createCommand, createQuery } from '../core';

    // Output schema for the query
    const PizzaOrderOutput = z.object({
      id: z.string(),
      size: z.enum(['small', 'medium', 'large']).optional(),
      type: z.string().optional(),
      status: z.enum(['pending', 'delivered']),
    });

    // Input schema for the command
    const CreateOrderInput = z.object({
      size: z.enum(['small', 'medium', 'large']),
      type: z.string(),
      address: z.string().min(10),
    });

    // Create "scaffolds" for commands and queries with their contracts.
    // The actual logic can be a placeholder for now.
    export const getOrderQuery = createQuery({
      input: z.object({ id: z.string() }),
      output: PizzaOrderOutput,
      execute: async ({ id }) => ({ id, status: 'pending' }), // Placeholder logic
    });

    export const createOrderCommand = createCommand({
      input: CreateOrderInput,
      output: PizzaOrderOutput,
      execute: async (input) => ({ id: '123', ...input, status: 'pending' }), // Placeholder logic
    });
    ```
**Result of Step 1:** We have a strictly-typed API for our business logic. The rest of the system will be built upon these types. Data-related errors are now preventable at compile time.

---

### Step 2: Describe the UI (Declarative Components)

With the data contracts established, we can now describe the UI.

1.  **Create Components:** For each screen (state) of the dialogue, create a corresponding component file (e.g., in `/src/flows/components/`).
2.  **Use UI Builders:** Use the `message` and `Keyboard` builders to define the text and buttons. The `props` for the component are inferred directly from the `output` schema of our queries.

    *AI Agent Action: Create `src/flows/pizza/SelectSize.component.ts`*
    ```typescript
    import { message, Keyboard } from '@bot-machine/ui'; // (hypothetical path)
    import { z } from 'zod';
    import { getOrderQuery } from '../../core/pizza';

    // The component's props type is inferred from the Zod schema!
    type Props = z.infer<typeof getOrderQuery.output>;

    export async function SelectSizeComponent(props: Props) {
      const kbd = new Keyboard()
        .text('Small', 'select_size:small')
        .text('Medium', 'select_size:medium')
        .text('Large', 'select_size:large');

      const msg = message(({ i, b }) => [
        b('Order #'), i(props.id), b(': Please select a size'),
      ]);

      return { ...msg, reply_markup: kbd.inline() };
    }
    ```
**Result of Step 2:** We have a collection of independent, strictly-typed UI components.

---

### Step 3: Define the Dialogue Flow (State Machine)

Here, we connect the business logic and the UI.

1.  **Create Flow File:** e.g., `src/flows/pizza/pizza.flow.ts`.
2.  **Describe States:** Using `createFlow`, define all states (`selectSize`, `selectType`, `getAddress`, `confirm`). For each state, wire up its `component`, its `onEnter` query (to fetch data), and its `onAction`/`onText` handlers (to process user input).

    *AI Agent Action: Update `pizza.flow.ts`*
    ```typescript
    export const pizzaFlow = createFlow({
      'selectSize': {
        component: SelectSizeComponent,
        onEnter: getOrderQuery, // Use the query from Step 1
        onAction: {
          'select_size::size': {
            command: updateOrderSizeCommand, // Use a command defined in Step 1
            nextState: 'selectType',
          }
        }
      },
      // ... other states
    });
    ```
**Result of Step 3:** The entire dialogue logic is described in a single, readable, and type-safe location.

---

### Step 4: Integrate and Implement

The final phase.

1.  **Register Flow:** In `index.ts`, add `router.addFlow(pizzaFlow)` and a command to enter the flow (e.g., `/pizza`).
2.  **Implement Logic:** Return to `src/core/pizza.ts` and fill in the real implementation logic inside the `execute` functions, replacing the placeholders. This is now the last and easiest step, as the entire framework and all data contracts are already in place and verified by the compiler.

### Conclusion

This workflow transforms development into a predictable, assembly-line process. An AI agent can execute these steps sequentially, and the system remains consistent and operational at every stage. This minimizes the probability of errors and makes the feature creation process transparent and manageable. This is the essence of AI-driven development.


--- /var/home/j4jk3wka/Code/computer-master-bot/packages/bot-machine/FUTURE_CONCEPTS.md ---


# Future Concepts & Hypotheses

This document contains forward-looking ideas and architectural hypotheses that are worth exploring in the future to further improve the framework's Developer Experience (DX).

## 1. Functional/Component-Based Text Builder

**Hypothesis:** A functional, component-based syntax for building messages could offer superior composability and readability compared to a purely fluent (chainable) API, especially for highly dynamic and complex messages.

### Core Concept

Instead of (or in addition to) the fluent `new Text().b('Hello').i('World')` API, we could offer a builder function that accepts a function as an argument. This argument function, in turn, receives the formatting methods as its own arguments, allowing for a syntax reminiscent of React functional components.

### Proposed Syntax Example

```typescript
// `txt` is the main builder function
const message = txt(({ b, i, l, n, user }) => [
  b(['Hello, ', user.firstName, '!']), // Methods can accept strings or arrays of fragments
  n(), // Newline
  i('Welcome to our bot.'),
  n(2), // Two newlines
  l('Visit our website', 'https://example.com'),
]);

// It could even allow for easy conditional logic and mapping
const welcomeMessage = (user) => txt(({ b, i, n, p }) => [
  b(['Welcome, ', user.name, '!']),
  n(),
  user.is_premium ? i('Thanks for being a premium member.') : p('Check out our premium offers.'),
  n(),
  p('Your items:'),
  ...user.items.map(item => p(`- ${item.name}`)), // Composition with standard JS
]);
```

### Key Ideas to Explore

*   **Composition:** The primary benefit is the ability to compose messages from smaller, reusable functional components.
*   **JavaScript-Native Logic:** Using a function allows developers to use standard JavaScript (`if/else`, `.map`, `...spread`) directly within the message definition, which is more powerful and familiar than a chained API.
*   **Readability:** For deeply nested or conditional UIs, this syntax can be significantly more readable than a long chain of method calls.
*   **`row` concept:** The user mentioned a `row` function. This could be explored as a way to logically group elements, although text in Telegram is linear. It might be a purely organizational tool or could imply specific styling/spacing.

**Next Steps (Future):**

1.  Build a Proof of Concept (PoC) for this API.
2.  Compare the DX of this functional style against the fluent builder for several complex message examples.
3.  Decide if this should replace, or be offered as an alternative to, the fluent builder API.


--- /var/home/j4jk3wka/Code/computer-master-bot/packages/bot-machine/KEYBOARD_BUILDER_SPEC.md ---


# Spec: Keyboard Builder

## 1. Rationale

Creating complex keyboards by manually constructing nested arrays is verbose, error-prone, and offers a poor Developer Experience (DX). To align with our goal of creating a simple and elegant low-code framework, we need a high-level abstraction for building keyboards.

This document specifies a `Keyboard` builder with a fluent (chainable) API, inspired by top-tier bot frameworks.

## 2. Proposed API

The builder will be a class that can be instantiated and then have methods chained to it to construct the keyboard row by row.

### Basic Example (Inline Keyboard)

```typescript
import { Keyboard } from './keyboard'; // Future implementation

const keyboard = new Keyboard()
  .text('Button 1', 'callback_1') // A button in the first row
  .text('Button 2', 'callback_2') // Another button in the first row
  .row() // Start a new row
  .url('Google', 'https://google.com'); // A URL button in the second row

// The builder can then be passed directly into the reply/edit methods.
// The framework will automatically call a method like .build() or .inline().
await ctx.reply('Message with a keyboard', { reply_markup: keyboard });
```

### Core Concepts

1.  **Chainable Methods:** Every method that adds a button returns `this` to allow chaining.
2.  **Row Management:** The `.row()` method explicitly moves to the next row. This is more readable than nested arrays.
3.  **Button Types:** The builder will have dedicated methods for each type of Telegram button.
4.  **Immutability (Optional but Recommended):** Each method call should ideally return a *new* instance of the builder to prevent accidental modification of a keyboard that is already in use elsewhere. (e.g., `const kb2 = kb1.row();`)
5.  **Output Generation:** The builder will have methods like `.inline()` and `.reply()` to generate the final `InlineKeyboardMarkup` or `ReplyKeyboardMarkup` object required by the Telegram API.

## 3. Required Methods

The `Keyboard` class should have the following methods.

### Row Management

*   `.row()`: Finalizes the current row and starts a new one.

### Inline Keyboard Buttons (`InlineKeyboardButton`)

*   `.text(text: string, callback_data: string)`: A standard button that sends a callback query.
*   `.url(text: string, url: string)`: A button that opens a URL.
*   `.login(text: string, login_url: string | LoginUrl)`: A button for a Telegram Login URL.
*   `.switchInline(text: string, query: string)`: A button that prompts the user to select a chat, opens it, and inserts the bot's username and a specified query.
*   `.switchInlineCurrent(text: string, query: string)`: Same as above, but inserts the query in the current chat.
*   `.webApp(text: string, web_app_info: WebAppInfo)`: A button that launches a Web App.
*   `.pay(text: string)`: A pay button (for Telegram Payments).

### Reply Keyboard Buttons (`KeyboardButton`)

*   `.requestContact(text: string)`: A button that requests the user's contact.
*   `.requestLocation(text: string)`: A button that requests the user's location.
*   `.requestPoll(text: string, type?: 'quiz' | 'regular')`: A button that allows the user to create and send a poll.

### Output Methods

*   `.inline()`: Returns the final `InlineKeyboardMarkup` object.
*   `.reply(options?: { resize?: boolean; one_time?: boolean; placeholder?: string; selective?: boolean })`: Returns the final `ReplyKeyboardMarkup` object.
*   `.remove(selective?: boolean)`: Returns a `ReplyKeyboardRemove` object.

## 4. Usage in Framework

The `ctx.reply` and `ctx.editMessageText` methods should be updated to accept an instance of the `Keyboard` builder directly in the `reply_markup` option, in addition to the raw object.

```typescript
// This should be possible
await ctx.reply('Text', { reply_markup: new Keyboard().text('Hi', 'hi') });

// As well as this
const kbd = new Keyboard().text('Hi', 'hi');
await ctx.reply('Text', { reply_markup: kbd });
```


--- /var/home/j4jk3wka/Code/computer-master-bot/packages/bot-machine/README.md ---

# bot-machine

To install dependencies:

```bash
bun install
```

To run:

```bash
bun run index.ts
```

This project was created using `bun init` in bun v1.2.19. [Bun](https://bun.com) is a fast all-in-one JavaScript runtime.


--- /var/home/j4jk3wka/Code/computer-master-bot/packages/bot-machine/TELEGRAM_FRAMEWORK_SPEC.md ---

# Спецификация фреймворка "BotExpress"

## 1. Обзор и Философия

**BotExpress** — это Node.js/Bun фреймворк для быстрой разработки Telegram-ботов, вдохновленный современными веб-фреймворками (Express.js, React) и принципами чистой архитектуры.

**Ключевые принципы:**

1.  **Гибридная архитектура:** Фреймворк сочетает в себе два подхода:
    *   **Stateless Router (в стиле MVC):** Для обработки простых, одноразовых команд и действий, не требующих сложного контекста.
    *   **FlowController (State Machine):** Для управления сложными, многошаговыми диалогами (регистрация, оформление заказа, квизы).

2.  **Декларативное описание UI:** Представления (сообщения в чате) описываются как чистые функции-"компоненты", которые принимают данные (`props`) и возвращают сериализуемый объект, описывающий сообщение для Telegram API.

3.  **Разделение ответственности (Decoupling):** Фреймворк отвечает за взаимодействие с Telegram API, роутинг, управление сессиями и рендеринг. Он полностью отделен от бизнес-логики приложения. Ядро бизнес-логики (например, написанное на SotaJS) подключается как внешний сервис.

## 2. Ключевые Компоненты

### `Router` (Stateless Роутер)

Основная точка входа. Маршрутизирует входящие `update` на соответствующие обработчики.

**API:**

*   `new Router()`: Создает экземпляр роутера.
*   `router.onCommand(command: string | RegExp, handler: Handler)`: Регистрирует обработчик для Telegram-команд (например, `/start`).
*   `router.onCallbackQuery(pattern: string | RegExp, handler: Handler)`: Регистрирует обработчик для нажатий на инлайн-кнопки. Может извлекать параметры из `callback_data` (например, `product:(.+)`).
*   `router.onText(pattern: string | RegExp, handler: Handler)`: Регистрирует обработчик для текстовых сообщений.
*   `router.use(middleware: Middleware)`: Добавляет middleware, которое выполняется для каждого `update`.
*   `router.addFlow(flow: FlowController)`: Регистрирует stateful-флоу, делегируя ему управление, если пользователь находится в этом флоу.
*   `router.handle(update: object)`: Основной метод, запускающий обработку `update`.

**Сигнатура обработчика (Handler):**
`type Handler = (ctx: Context) => Promise<void>;`

### `Context` (Объект `ctx`)

Абстракция над `update` от Telegram, предоставляющая удобный API для ответа. Передается в каждый `handler` и `middleware`.

**Свойства:**

*   `ctx.update`: "Сырой" объект `update` от Telegram.
*   `ctx.from`: Информация о пользователе (`update.message.from` или `update.callback_query.from`).
*   `ctx.chat`: Информация о чате.
*   `ctx.session`: Объект сессии пользователя. Заполняется `SessionManager`.
*   `ctx.state`: Объект для передачи данных между `middleware` в рамках одного запроса.
*   `ctx.params`: Параметры, извлеченные из `RegExp` в роутере (например, ID продукта из `product:(.+)`).

**Методы:**

*   `ctx.reply(text: string, extra?: object)`: Отправляет новое сообщение.
*   `ctx.editMessageText(text: string, extra?: object)`: Редактирует текущее сообщение.
*   `ctx.deleteMessage()`: Удаляет сообщение.
*   `ctx.answerCallbackQuery(text?: string)`: Отвечает на `callback_query`.
*   `ctx.enterFlow(flowName: string, initialState?: string)`: Принудительно запускает stateful-флоу для пользователя.

### `FlowController` (State Machine)

Управляет сложными, многошаговыми диалогами.

**API:**

*   `new FlowController(config)`: Создает экземпляр state-машины на основе конфигурации.
*   `createFlow(config)`: Фабрика для создания конфигурации.

**Конфигурация флоу:**

Объект, где ключи — названия состояний. Каждое состояние описывается объектом:

*   `component: ComponentFunction`: Функция-компонент для рендеринга этого состояния.
*   `onEnter?: QueryFunction`: (Опционально) **Запрос** из ядра, который нужно выполнить при входе в состояние, чтобы получить данные для компонента.
*   `onAction?: { [pattern: string]: ActionHandler }`: Карта обработчиков действий в этом состоянии.
    *   `pattern`: `RegExp` или строка для `callback_data`.
    *   `ActionHandler`:
        *   `command: CommandFunction`: **Команда** из ядра для выполнения.
        *   `nextState: string | ((dto: any) => string)`: Следующее состояние (может быть функцией от результата команды).
        *   `refresh?: boolean`: Если `true`, после выполнения команды нужно обновить текущее представление, а не переходить в новое состояние.

### `Component`

Простая асинхронная функция, принимающая `props` и возвращающая объект `MessagePayload`.

*   **Сигнатура:** `type Component = (props: any) => Promise<MessagePayload>;`
*   **`MessagePayload`:** Объект, описывающий сообщение для Telegram API (`text`, `reply_markup`, `parse_mode` и т.д.).

### `SessionManager` (Middleware)

Middleware для управления сессиями. Должен быть добавлен через `router.use()`.

**API:**

*   `new SessionManager({ store: ISessionStore })`

**Интерфейс `ISessionStore`:**

*   `get(key: string): Promise<Session>`
*   `set(key: string, value: Session, ttl?: number): Promise<void>`

По умолчанию предоставляет `InMemorySessionStore`. Для production-использования (особенно в serverless) должен быть заменен на адаптер для Redis, Mongo и т.д.

## 3. Жизненный цикл запроса

### Stateless-сценарий (через `Router`)

1.  `Update` от Telegram поступает в `router.handle(update)`.
2.  `SessionManager` загружает `ctx.session`.
3.  `Router` находит подходящий обработчик (`onCommand`, `onCallbackQuery` и т.д.).
4.  Выполняется `Handler`, который может вызвать ядро и использует `ctx` для ответа.

### Stateful-сценарий (через `FlowController`)

1.  `Update` поступает в `router.handle(update)`.
2.  `SessionManager` загружает `ctx.session`.
3.  `Router` видит, что пользователь находится в активном флоу (`session.flowName`), и передает `update` в соответствующий `FlowController`.
4.  `FlowController` находит текущее состояние (`session.currentState`) и обработчик для `update` в `onAction`.
5.  Вызывается **Команда** из ядра.
6.  `FlowController` получает DTO от Команды, обновляет сессию на `nextState`.
7.  `FlowController` смотрит на новое состояние, видит `onEnter` **Запрос** и выполняет его.
8.  `FlowController` получает DTO от Запроса и передает его в `Component` для рендеринга.
9.  Сгенерированный `MessagePayload` отправляется в Telegram.

## 4. Пример реализации: Бот-счетчик

*Предполагается, что ядро на SotaJS с `getCounterQuery`, `incrementCounterCommand`, `decrementCounterCommand` уже написано.*

**`bot/Counter.component.ts`**
```typescript
export async function CounterComponent(props: { count: number }) {
  return {
    text: `Текущее значение: <b>${props.count}</b>`,
    parse_mode: 'HTML',
    reply_markup: {
      inline_keyboard: [[
        { text: '➖', callback_data: 'decrement' },
        { text: '➕', callback_data: 'increment' },
      ]],
    },
  };
}
```

**`bot/main.flow.ts`**
```typescript
import { createFlow } from './sota-tele-bridge';
import { CounterComponent } from './Counter.component';
import { getCounterQuery, incrementCounterCommand, decrementCounterCommand } from '../src/counter'; // Импорты из ядра

export const mainFlow = createFlow({
  'counter': {
    component: CounterComponent,
    onEnter: getCounterQuery, // Получить счетчик при входе в состояние
    onAction: {
      'increment': {
        command: incrementCounterCommand,
        refresh: true, // Обновить текущий экран, используя DTO от команды
      },
      'decrement': {
        command: decrementCounterCommand,
        refresh: true,
      },
    },
  },
});
```

**`bot/index.ts`**
```typescript
import { Telegraf } from 'telegraf';
import { Router, SessionManager, FlowController } from './sota-tele-bridge';
import { mainFlow } from './main.flow';
// ...настройка портов SotaJS...

const bot = new Telegraf(process.env.BOT_TOKEN!);
const router = new Router();
const sessionManager = new SessionManager({ store: new InMemorySessionStore() });
const mainFlowController = new FlowController(mainFlow, 'mainFlow');

// Middleware для сессий
router.use(sessionManager.middleware());

// Делегируем управление FlowController, если пользователь в этом флоу
router.addFlow(mainFlowController);

// Точка входа в наш stateful-сценарий
router.onCommand('start', (ctx) => ctx.enterFlow('mainFlow', 'counter'));

// Обработчик для всех апдейтов
bot.on('update', (update) => router.handle(update));

bot.launch();
```

## 5. Взаимодействие с SotaJS

Фреймворк `SotaTele` является "потребителем" (consumer) ядра, написанного на SotaJS.

*   **Точки интеграции:**
    *   В `handler`-функциях stateless-роутера.
    *   В полях `command` и `onEnter` конфигурации `FlowController`.
*   **Контракт:** Взаимодействие происходит через вызов функций **Команд** и **Запросов** и получение от них **DTO**. Фреймворк не знает о внутренней реализации ядра (агрегаты, порты, адаптеры).

Это обеспечивает полное разделение и позволяет независимо разрабатывать и тестировать бизнес-логику и логику представления/диалога.


--- /var/home/j4jk3wka/Code/computer-master-bot/packages/bot-machine/TEXT_BUILDER_SPEC.md ---


# Spec: Text Builder

## 1. Rationale

Composing messages with rich text formatting (bold, italic, links, etc.) using raw HTML or Markdown strings is cumbersome and error-prone. It forces the developer to manually handle tags and entities, which can lead to parsing errors and a poor Developer Experience (DX).

A `Text` builder will provide a fluent, safe, and declarative API for constructing richly formatted messages.

## 2. Proposed API

The builder will be a class that manages a collection of text fragments, each with its own formatting. It will automatically handle the assembly of the final string and determine the correct `parse_mode`.

### Basic Example

```typescript
import { Text } from './text'; // Future implementation

const message = new Text()
  .bold('Hello, ').text(ctx.from.first_name).plain('!') // Chain formatting on one line
  .newline(2) // Add two newlines
  .italic('This is a bot-machine bot.')
  .newline()
  .link('Visit our website', 'https://example.com');

// The builder then provides the final text and the correct parse mode.
await ctx.reply(message.build(), { parse_mode: message.parseMode() });
// Or, even better, the context methods could accept the builder directly.
await ctx.reply(message);
```

### Core Concepts

1.  **Fluent Interface:** All methods for adding text fragments return `this` to allow chaining.
2.  **Automatic `parse_mode`:** The builder tracks which formatting methods are used. If any method requiring HTML is called (e.g., `.link()`), `parseMode()` will return `'HTML'`. Otherwise, it could potentially use `'MarkdownV2'` or no `parse_mode` at all.
3.  **Entity Management:** Internally, the builder does not just concatenate strings. It should manage an array of text fragments and their associated formatting types. The `.build()` method then intelligently constructs the final string with the correct tags.
4.  **Escaping:** The builder will be responsible for automatically escaping special characters in plain text fragments to prevent them from being interpreted as formatting tags.

## 3. Required Methods

The `Text` class should have the following methods.

### Content Methods

*   `.text(content: string | number)` or `.plain(...)`: Adds a plain text fragment (with escaping).
*   `.bold(content: string | number)`: Adds a bolded fragment.
*   `.italic(content: string | number)`: Adds an italicized fragment.
*   `.underline(content: string | number)`: Adds an underlined fragment.
*   `.strikethrough(content: string | number)`: Adds a strikethrough fragment.
*   `.spoiler(content: string | number)`: Adds a spoiler fragment.
*   `.code(content: string | number)`: Adds an inline, fixed-width code fragment.
*   `.pre(content: string | number, language?: string)`: Adds a pre-formatted code block.
*   `.link(text: string, url: string)`: Adds a hyperlink.
*   `.mention(text: string, user_id: number)`: Adds an inline mention of a user.
*   `.hashtag(content: string)`: Adds a hashtag.
*   `.newline(count: number = 1)`: Adds one or more newline characters.

### Shorthand Aliases

To improve DX and reduce verbosity for complex messages, each content method should also have a short alias.

*   `.text()` -> `.t()`
*   `.plain()` -> `.p()`
*   `.bold()` -> `.b()`
*   `.italic()` -> `.i()`
*   `.underline()` -> `.u()`
*   `.strikethrough()` -> `.s()`
*   `.spoiler()` -> `.sp()`
*   `.code()` -> `.c()`
*   `.pre()` -> `.pr()`
*   `.link()` -> `.l()`
*   `.mention()` -> `.m()`
*   `.hashtag()` -> `.h()`
*   `.newline()` -> `.n()`

### Output Methods

*   `.build()`: Constructs and returns the final formatted string (e.g., with HTML tags).
*   `.parseMode()`: Returns the appropriate `parse_mode` for the built string (`'HTML'`, `'MarkdownV2'`, or `undefined`).

## 4. Usage in Framework

Ideally, `ctx.reply` and `ctx.editMessageText` would be overloaded to accept an instance of the `Text` builder directly. The methods would then internally call `.build()` and `.parseMode()`.

```typescript
// This should be the final DX goal
const message = new Text()
  .bold('Hello, ').text(ctx.from.first_name);

await ctx.reply(message);
```



--- End of content ---